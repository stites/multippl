======================
exact: untyped trivial
======================

exact {
  let x = true in x
}

---

(source_file
  (program
    (elet
      (identifier)
      (eanf (bool))
    (eanf (identifier)))))

======================
exact: typed trivial
======================

exact {
  let x : Bool = true in
  x : Bool
}

---

(source_file
  (program
    (elet
      (identifier)
      (ety (tyBool))
      (eanf (bool))
    (eann (eanf (identifier)) (ety (tyBool))))))

======================
exact: FIXME!!! trivial with extra annotation (not sure if types are going to the right places)
======================

exact {
  let x : Bool = true in
  (x : Bool) : Bool
}

---


(source_file
  (program
    (elet
      (identifier)
      (ety (tyBool))
      (eanf (bool))
    (eann
      (eann (eanf (identifier)) (ety (tyBool)))
       (ety (tyBool))))))


======================
exact: trivial with extra product annotation
======================

exact {
  let x : Bool = true in
  (x : (Bool, Bool)) : (Bool, Bool, Bool)
}

---

(source_file
(program
  (elet
    (identifier) (ety (tyBool))
    (eanf (bool))
    (eann (eann (eanf (identifier)) (ety (tyProd (ety (tyBool)) (ety (tyBool))))) (ety (tyProd (ety (tyBool)) (ety (tyBool)) (ety (tyBool))))) ))
)

======================
exact: one typed flip
======================


exact {
  let x : Bool = flip (1.0 / 3.0)  in
  (x : Bool) : Bool
}


---

(source_file
  (program
    (elet
      (identifier)
      (ety (tyBool))
      (eflip (eanf (eanf (eanf (float)) (numeric_op) (eanf (float)))))
    (eann
      (eann (eanf (identifier)) (ety (tyBool)))
       (ety (tyBool))))))


======================
exact: one untyped flip
======================

exact {
  let x = flip (1/3) in
  x
}

---


(source_file
  (program
    (elet
      (identifier)
      (eflip (eanf (eanf (eanf (int)) (numeric_op) (eanf (int)))))
      (eanf (identifier))
       )))


======================
exact: one flip needs inference
======================
exact {
  let x : Bool = flip (1/3) in
  x
}
---

(source_file
 (program
  (elet
    (identifier) (ety (tyBool))
    (eflip (eanf (eanf (eanf (int)) (numeric_op) (eanf (int)))))
  (eanf (identifier))
  )))


======================
exact: two flips untyped
======================

exact {
  let x = flip 0.3333 in
  let y = flip 1/4 in
  x || y
}

---

(source_file
 (program
  (elet (identifier) (eflip (eanf (float)))
   (elet (identifier) (eflip (eanf (eanf (int)) (numeric_op) (eanf (int))))
    (eanf (eanf (identifier)) (bool_biop) (eanf (identifier)))
   )
  )
 )
)

===========================
exact: observed two flips
===========================

exact {
  let x = flip 0.3333 in
  let y = flip 1/4 in
  let _ = observe (x || y) in
  x
}

---


(source_file
 (program
  (elet
    (identifier)
    (eflip (eanf (float)))
  (elet
    (identifier)
    (eflip (eanf (eanf (int)) (numeric_op) (eanf (int))))
  (elet
    (identifier)
    (eobserve (eanf (eanf (eanf (identifier)) (bool_biop) (eanf (identifier)))))
  (eanf (identifier)))))))


======================
exact(hybrid): observed two flips
======================

exact {
  let x = sample(~bern(1/3)) in
  let y = flip 1/4 in
  let _ = observe (x || y) in
  x
}

---

(source_file
  (program
    (elet
      (identifier)
      (esample (ssample (sanf (sbern (sanf (sanf (int)) (numeric_op) (sanf (int)))))))
    (elet
      (identifier)
      (eflip (eanf (eanf (int)) (numeric_op) (eanf (int))))
    (elet
      (identifier)
      (eobserve (eanf (eanf (eanf (identifier)) (bool_biop) (eanf (identifier)))))
    (eanf (identifier)))))))

======================
exact: discrete zero is invalid
======================

exact {
  discrete()
}

---
(source_file
  (program
      (ediscrete
        (eanf
          (MISSING identifier)))))

======================
exact: discrete 1 arg
======================

exact {
  discrete(0.)
}

---

(source_file
  (program
    (ediscrete
      (eanf
        (float)))))

======================
exact: discrete 3 arg
======================

exact {
  discrete (0., 0.2, 1.5)
}

---


(source_file
  (program
      (ediscrete
        (eanf (float))
        (eanf (float))
        (eanf (float))
        )))

======================
exact: bounded iteration
======================

exact {
  iterate(fun, init, k)
}

---


(source_file
  (program
      (eiterate
        (identifier)
        (eanf (identifier))
        (eanf (identifier))
        )))

==================
exact: diamond network
==================
exact fn diamond (s1:Bool):Bool {
  let route = flip 0.5 in
  let s2 = if route then s1 else false in
  let s3 = if route then false else s1 in
  let drop = flip 0.0001 in
  s2 || (s3 && !drop)
}
exact {
  let net1 = diamond(true) in
  let net2 = diamond(net1) in
  diamond(net2)
}
---------

(source_file
  (program
    (efun
      (identifier)
      (eargs (identifier) (ety (tyBool)))
      (ety (tyBool))
    (elet (identifier) (eflip (eanf (float)))
    (elet (identifier)
          (eite (eanf (identifier)) (eanf (identifier)) (eanf (bool)))
    (elet (identifier)
          (eite (eanf (identifier)) (eanf (bool)) (eanf (identifier)))
    (elet (identifier) (eflip (eanf (float)))
          (eanf (eanf (identifier))
                (bool_biop)
                (eanf (eanf (eanf (identifier))
                    (bool_biop)
                    (eanf (bool_unop) (eanf (identifier)))))))))))


    (program
      (elet (identifier) (eapp (identifier) (eanf (bool)))
      (elet (identifier) (eapp (identifier) (eanf (identifier)))
      (eapp (identifier) (eanf (identifier))))))))

==================
exact(hybrid): arrival problem on diamond-network
==================
exact fn diamond (s1:Bool):Bool {
  let route = flip 0.5 in
  let s2 = if route then s1 else false in
  let s3 = if route then false else s1 in
  let drop = flip 0.0001 in
  s2 || (s3 && !drop)
}
exact {
  let p = sample(poisson(0.4)) in
  iterate(diamond, true, p)
}
---------


(source_file
  (program
    (efun
      (identifier)
      (eargs (identifier) (ety (tyBool)))
      (ety (tyBool))
    (elet (identifier) (eflip (eanf (float)))
    (elet (identifier)
          (eite (eanf (identifier)) (eanf (identifier)) (eanf (bool)))
    (elet (identifier)
          (eite (eanf (identifier)) (eanf (bool)) (eanf (identifier)))
    (elet (identifier) (eflip (eanf (float)))
          (eanf (eanf (identifier))
                (bool_biop)
                (eanf (eanf (eanf (identifier))
                    (bool_biop)
                    (eanf (bool_unop) (eanf (identifier)))))))))))

    (program
      (elet (identifier) (esample (sanf (spoisson (sanf (float)))))
      (eiterate (identifier) (eanf (bool)) (eanf (identifier)))))))
