exact fn network(obsA: Int, obsB: Int, obsC: Int, obsF: Int) -> (Int, Int, Int, Int) {
   let A = discrete(1.0, 1.0) in
   let B = discrete(1.0, 1.0, 1.0) in
   let C = discrete(1.0, 1.0, 1.0, 1.0) in
   let F =
     if B == 0 && C == 0 then discrete(1.0, 1.0) else
     if B == 0 && C == 1 then discrete(1.0, 1.0) else
     if B == 0 && C == 2 then discrete(1.0, 1.0) else
     if B == 0 && C == 3 then discrete(1.0, 1.0) else
     if B == 1 && C == 0 then discrete(1.0, 1.0) else
     if B == 1 && C == 1 then discrete(1.0, 1.0) else
     if B == 1 && C == 2 then discrete(1.0, 1.0) else
     if B == 1 && C == 3 then discrete(1.0, 1.0) else
     if B == 2 && C == 0 then discrete(1.0, 1.0) else
     if B == 2 && C == 1 then discrete(1.0, 1.0) else
     if B == 2 && C == 2 then discrete(1.0, 1.0) else
     if B == 2 && C == 3 then discrete(1.0, 1.0) else
                      discrete(1.0, 1.0)
   in
   observe A == obsA
   observe B == obsB
   observe C == obsC
   observe F == obsF
   (A, B, C, F)
}
exact {


}