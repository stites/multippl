// skip -- this isn't supported in PSI.

def network(){
  x00 := flip(0.5);
  x01 := if x00 { flip(1/3) } else { flip(1/4) };
  x10 := if x00 { flip(1/5) } else { flip(1/6) };
  x20 := if x10 { flip(1/5) } else { flip(1/6) };
  x11 :=
    if  x10 &&  x01 { flip(1/7) } else {
    if  x10 && !x01 { flip(1/8) } else {
    if !x10 &&  x01 { flip(1/9) } else {
                      flip(1/11) } } };
  x02 := if x01 { flip(1/3) } else { flip(1/4) };
  x12 :=
    if  x11 &&  x02 { flip(6/7) } else {
    if  x11 && !x02 { flip(6/8) } else {
    if !x11 &&  x02 { flip(6/9) } else {
                      flip(6/11) } } };

  x21 :=
    if  x20 &&  x11 { flip(2/7) } else {
    if  x20 && !x11 { flip(2/8) } else {
    if !x20 &&  x11 { flip(2/9) } else {
                      flip(2/11) } } };

  x22 :=
    if  x21 &&  x12 { flip(3/7) } else {
    if  x21 && !x12 { flip(3/8) } else {
    if !x21 &&  x12 { flip(8/9) } else {
                      flip(9/11) } } };
  observe !21;

  return x01;
}

// this program results in an error as Poisson's support is â„• and we can't prove the bound is tractible.
def main () {
  ix := poisson(3.0);
  npackets := 0;
  // assert(ix <= 10); // even applying an assert will fail, as it is not provable.
  for i in [0..ix) {
    traverses := network();
    npackets += (if traverses { 1 } else { 0 });
  };
  return Expectation(npackets);
}
