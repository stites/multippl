exact fn forward0() -> Int {
  let s = discrete(1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0) in s + 1
}
exact fn forward1() -> Int {
  let s = discrete(1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0) in
  if s == 0 then s else s + 1
}
exact fn forward2() -> Int {
  let s = discrete(1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0) in
  if s == 0 then s else
  if s == 1 then s else s + 1
}
exact fn forward3() -> Int {
  let s = discrete(1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0) in
  if s == 0 then s else
  if s == 1 then s else
  if s == 2 then s else s + 1
}
exact fn forward4() -> Int {
  let s = discrete(1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0) in
  if s == 0 then s else
  if s == 1 then s else
  if s == 2 then s else
  if s == 3 then s else s + 1
}
exact fn forward5() -> Int {
  let s = discrete(1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0) in
  if s == 0 then s else
  if s == 1 then s else
  if s == 2 then s else
  if s == 3 then s else
  if s == 4 then s else s + 1
}
exact fn forward6() -> Int {
  let s = discrete(1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0) in
  if s == 0 then s else
  if s == 1 then s else
  if s == 2 then s else
  if s == 3 then s else
  if s == 4 then s else
  if s == 5 then s else s + 1
}
exact fn forward7() -> Int {
  let s = discrete(1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0) in
  if s == 0 then s else
  if s == 1 then s else
  if s == 2 then s else
  if s == 3 then s else
  if s == 4 then s else
  if s == 5 then s else
  if s == 6 then s else s + 1
}
exact fn forward8() -> Int {
  let s = discrete(1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0) in
  if s == 0 then s else
  if s == 1 then s else
  if s == 2 then s else
  if s == 3 then s else
  if s == 4 then s else
  if s == 5 then s else
  if s == 6 then s else
  if s == 7 then s else s + 1
}
exact fn forward9() -> Int {
  let s = discrete(1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0) in
  if s == 0 then s else
  if s == 1 then s else
  if s == 2 then s else
  if s == 3 then s else
  if s == 4 then s else
  if s == 5 then s else
  if s == 6 then s else
  if s == 7 then s else
  if s == 8 then s else s + 1
}
exact fn forward10() -> Int {
  let s = discrete(1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0) in
  if s == 0 then s else
  if s == 1 then s else
  if s == 2 then s else
  if s == 3 then s else
  if s == 4 then s else
  if s == 5 then s else
  if s == 6 then s else
  if s == 7 then s else
  if s == 9 then s else
  if s == 8 then s else s + 1
}
exact fn network_step(
    n0 : Bool,
    n1 : Bool,
    n2 : Bool,
    n3 : Bool,
    n4 : Bool,
    n5 : Bool,
    n6 : Bool,
    n7 : Bool,
    n8 : Bool,
    n9 : Bool,
    next : Int) -> (Bool, Bool, Bool, Bool, Bool, Bool, Bool, Bool, Bool, Bool, Int, Int) {
  // the incoming packet performs the infection
  if next == 0 then let p1 = forward0() in let p2 = forward0() in (true,   n1,   n2,   n3,   n4,    n5,    n6,    n7,    n8,    n9, p1, p2) else
  if next == 1 then let p1 = forward1() in let p2 = forward1() in (  n0, true,   n2,   n3,   n4,    n5,    n6,    n7,    n8,    n9, p1, p2) else
  if next == 2 then let p1 = forward2() in let p2 = forward2() in (  n0,   n1, true,   n3,   n4,    n5,    n6,    n7,    n8,    n9, p1, p2) else
  if next == 3 then let p1 = forward3() in let p2 = forward3() in (  n0,   n1,   n2, true,   n4,    n5,    n6,    n7,    n8,    n9, p1, p2) else
  if next == 4 then let p1 = forward4() in let p2 = forward4() in (  n0,   n1,   n2,   n3, true,    n5,    n6,    n7,    n8,    n9, p1, p2) else
  if next == 5 then let p1 = forward5() in let p2 = forward5() in (  n0,   n1,   n2,   n3,   n4,  true,    n6,    n7,    n8,    n9, p1, p2) else
  if next == 6 then let p1 = forward6() in let p2 = forward6() in (  n0,   n1,   n2,   n3,   n4,    n5,  true,    n7,    n8,    n9, p1, p2) else
  if next == 7 then let p1 = forward7() in let p2 = forward7() in (  n0,   n1,   n2,   n3,   n4,    n5,    n6,  true,    n8,    n9, p1, p2) else
  if next == 8 then let p1 = forward8() in let p2 = forward8() in (  n0,   n1,   n2,   n3,   n4,    n5,    n6,    n7,  true,    n9, p1, p2) else
                    let p1 = forward9() in let p2 = forward9() in (  n0,   n1,   n2,   n3,   n4,    n5,    n6,    n7,    n8,  true, p1, p2)
}

sample fn as_num(b : Bool) -> Float {
  if (b) { 1.0 } else { 0.0 }
}

sample {
  // first we sample two packets from the starting node 0
  p1 <- exact(forward0());
  p2 <- exact(forward0());

  i0 <- true;
  i1 <- false;
  i2 <- false;
  i3 <- false;
  i4 <- false;
  i5 <- false;
  i6 <- false;
  i7 <- false;
  i8 <- false;
  i9 <- false;

  q  <- [];
  q  <- push(q, p1);
  q  <- push(q, p2);
  num_steps <- 3;
  while (num_steps > 0) {
    nxt <- head(q);
    q   <- tail(q);
    state <- exact(network_step(i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, nxt));

    i0 <- state[0];
    i1 <- state[1];
    i2 <- state[2];
    i3 <- state[3];
    i4 <- state[4];
    i5 <- state[5];
    i6 <- state[6];
    i7 <- state[7];
    i8 <- state[8];
    i9 <- state[9];
    q  <- push(q, state[10]);
    q  <- push(q, state[11]);
    num_steps <- num_steps - 1;
    true
  };
  n0 <- as_num(i0);
  n1 <- as_num(i1);
  n2 <- as_num(i2);
  n3 <- as_num(i3);
  n4 <- as_num(i4);
  n5 <- as_num(i5);
  n6 <- as_num(i6);
  n7 <- as_num(i7);
  n8 <- as_num(i8);
  n9 <- as_num(i9);
  out <- (n0 + n1 + n2 + n3 + n4 + n5 + n6 + n7 + n8 + n9);
  out
}
