exact fn state_model (
  ptA : Float,
  ptB : Float,
  ptC : Float,
  peA : Float,
  peB : Float,
  peC : Float,
  state: Int,
  o : Int
) -> Int {
    // first, transition from state t to t+1
    if      state == 1 then
        let st = discrete(ptA[0], ptA[1], ptA[2])  in
            // then, observe an emission probability and return state t+1 (for the next transition)
            if      st == 1 then let emit = discrete(peA[0], peA[1], peA[2]) in observe emit == o in st
            else if st == 2 then let emit = discrete(peB[0], peB[1], peB[2]) in observe emit == o in st
                            else let emit = discrete(peC[0], peC[1], peC[2]) in observe emit == o in st
    else if state == 2 then
        let st = discrete(ptB[0], ptB[1], ptB[2]) in
            if      st == 1 then let emit = discrete(peA[0], peA[1], peA[2]) in observe emit == o in st
            else if st == 2 then let emit = discrete(peB[0], peB[1], peB[2]) in observe emit == o in st
                            else let emit = discrete(peC[0], peC[1], peC[2]) in observe emit == o in st
    else
        let st = discrete(ptC[0], ptC[1], ptC[2]) in
            if      st == 1 then let emit = discrete(peA[0], peA[1], peA[2]) in observe emit == o in st
            else if st == 2 then let emit = discrete(peB[0], peB[1], peB[2]) in observe emit == o in st
                            else let emit = discrete(peC[0], peC[1], peC[2]) in observe emit == o in st
}

// this is a test
sample fn sequence_model (
  ptA : [Float],
  ptB : [Float],
  ptC : [Float],
  peA : [Float],
  peB : [Float],
  peC : [Float],
  len: Int,
  obs: [Int]
) -> Bool  {
  ix <- 0;
  s <- 1;
  while ix < len {
    s <- exact(state_model(ptA, ptB, ptC, peA, peB, peC, s, obs[ix]));
    ix <- ix + 1;
    true
  };
  true
}
sample {
  ptA ~ dirichlet(0.5, 0.5, 0.5); // [0.3, 0.6, 0.1]
  ptB ~ dirichlet(0.5, 0.5, 0.5); // [0.6, 0.1, 0.3]
  ptC ~ dirichlet(0.5, 0.5, 0.5); // [0.25, 0.50, 0.05]

  peA ~ dirichlet(0.5, 0.5, 0.5); // [0/3, 2/3, 1/3],
  peB ~ dirichlet(0.5, 0.5, 0.5); // [3/6, 2/6, 1/6],
  peC ~ dirichlet(0.5, 0.5, 0.5); // [1/12, 1/12, 10/12],

  sequence_model(ptA, ptB, ptC, peA, peB, peC, lens1, seqs1);
  sequence_model(ptA, ptB, ptC, peA, peB, peC, lens2, seqs2);
  sequence_model(ptA, ptB, ptC, peA, peB, peC, lens3, seqs3);
  sequence_model(ptA, ptB, ptC, peA, peB, peC, lens4, seqs4);
  sequence_model(ptA, ptB, ptC, peA, peB, peC, lens5, seqs5);

  (ptA, ptB, ptC, peA, peB, peC)
}
